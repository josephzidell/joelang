import { Node, NT, UnaryExpressionNode } from '../parser/types';
import { Result } from '../shared/result';
import { AST } from './asts';
import AnalysisError from './error';
import SemanticAnalyzer from './semanticAnalyzer';
import SemanticError from './semanticError';
import SymbolError from './symbolError';

export type visitor = (node: Node, analyzer: SemanticAnalyzer) => Result<AST | AST[], AnalysisError | SemanticError | SymbolError>;

const visitorMap: Record<NT, visitor> = {
	[NT.ArgumentsList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitArgumentList(node),
	[NT.ArrayExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitArrayExpression(node),
	[NT.ArrayOf]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitArrayOf(node),
	[NT.AssignablesList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitAssignablesList(node),
	[NT.AssigneesList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitAssigneesList(node),
	[NT.AssignmentExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitAssignmentExpression(node),
	[NT.AssignmentOperator]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.BinaryExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitBinaryExpression(node),
	[NT.BlockStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitBlockStatement(node),
	[NT.BoolLiteral]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitBoolLiteral(node),
	[NT.CallExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitCallExpression(node),
	[NT.ClassDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitClassDeclaration(node),
	[NT.ClassImplement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitDeclarationExtendsOrImplements(node),
	[NT.ClassImplementsList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitClassImplementsList(node),
	[NT.ColonSeparator]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.CommaSeparator]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.Comment]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.DoneStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitDoneStatement(node),
	[NT.ElseStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitElseStatement(node),
	[NT.EnumDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitEnumDeclaration(node),
	[NT.Extension]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitDeclarationExtendsOrImplements(node),
	[NT.ExtensionsList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitExtensionsList(node),
	[NT.ForStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitForStatement(node),
	[NT.FromKeyword]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.FunctionDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitFunctionDeclaration(node),
	[NT.FunctionReturns]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitFunctionReturns(node),
	[NT.FunctionSignature]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitFunctionSignature(node),
	[NT.Identifier]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitIdentifier(node),
	[NT.IfStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitIfStatement(node),
	[NT.InKeyword]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.InterfaceDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitInterfaceDeclaration(node),
	[NT.JoeDoc]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitJoeDoc(node),
	[NT.LoopStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitLoopStatement(node),
	[NT.MemberExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitMemberExpression(node),
	[NT.MemberList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitMemberList(node),
	[NT.MemberListExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitMemberListExpression(node),
	[NT.Modifier]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitModifier(node),
	[NT.ModifiersList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitModifiersList(node),
	[NT.NextStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitNextStatement(node),
	[NT.NumberLiteral]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitNumberLiteral(node),
	[NT.ObjectExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitObjectExpression(node),
	[NT.ObjectShape]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitObjectShape(node),
	[NT.Parameter]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitParameter(node),
	[NT.ParametersList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitParametersList(node),
	[NT.Parenthesized]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitParenthesized(node),
	[NT.Path]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitPath(node),
	[NT.PostfixIfStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitPostfixIfStatement(node),
	[NT.PrintStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitPrintStatement(node),
	[NT.Program]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitProgram(node),
	[NT.Property]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitProperty(node),
	[NT.PropertyShape]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitPropertyShape(node),
	[NT.RangeExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitRangeExpression(node),
	[NT.RegularExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitRegularExpression(node),
	[NT.RestElement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitRestElement(node),
	[NT.ReturnStatement]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitReturnStatement(node),
	[NT.RightArrowOperator]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.SemicolonSeparator]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.noop(node),
	[NT.StringLiteral]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitStringLiteral(node),
	[NT.TernaryAlternate]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTernaryAlternate(node),
	[NT.TernaryCondition]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTernaryCondition(node),
	[NT.TernaryConsequent]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTernaryConsequent(node),
	[NT.TernaryExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTernaryExpression(node),
	[NT.ThisKeyword]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitThisKeyword(node),
	[NT.TupleExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTupleExpression(node),
	[NT.TupleShape]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTupleShape(node),
	[NT.Type]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitType(node),
	[NT.TypeArgumentsList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTypeArgumentsList(node),
	[NT.TypeInstantiationExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTypeInstantiationExpression(node),
	[NT.TypeParameter]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTypeParameter(node),
	[NT.TypeParametersList]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitTypeParametersList(node),
	[NT.UnaryExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitUnaryExpression(node as UnaryExpressionNode),
	[NT.UseDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitUseDeclaration(node),
	[NT.VariableDeclaration]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitVariableDeclaration(node),
	[NT.WhenCase]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitWhenCase(node),
	[NT.WhenCaseConsequent]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitWhenCaseConsequent(node),
	[NT.WhenCaseValues]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitWhenCaseValues(node),
	[NT.WhenExpression]: (node: Node, analyzer: SemanticAnalyzer) => analyzer.visitWhenExpression(node),
};

export default visitorMap;
